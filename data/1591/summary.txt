Профилирование проводилось при помощи программы VisualVM 2.1.4.
Приложение запускалось с параметрами VM: -XX:+UseParallelGC -Xmx64m -Xms64m.

Анализ графика использования памяти (VisualVM.jpg) и лога GC (log.txt):
- При добавлении большого кол-ва заявок (100 000) видно увеличение размера используемой памяти.
- Анализ лога показывает, что первые 3 групповые добавления вызвали сборки мусора. Время сборок практически
совпадает с временем добавления. Причем только 3-е добавление вызвало полную сборку. Первые 2 вызывали
сборку по молодому поколению.
- Получение списка всех заявок (300 000) также приводит к активной работе сборщика мусора. Причем
выполняются полные сборки.
- Удаление половины (150 000) заявок приводит к полной сборке мусора, результаты которой хорошо видны на
графике: очищается около половины используемой памяти.
- Следующее добавление 100 000 заявок значительно увеличивает размер используемой памяти.
- Многократное добавление по 10 000 заявок приводит к активной работе сборщика мусора. Это происходит из-за
малого объема свободной памяти. Сборщик пытается её освободить. Ведутся только полные сборки.
На графике видно, что существенного освобождения памяти не происходит. Можно сказать, что это моделирование
утечки памяти, когда объекты постоянно создаются, но не удаляются.
В итоге память в Heap'е заканчивается и приложение завершается с java.lang.OutOfMemoryError.
